##################
多线程 vs 多进程

1.程序: 一堆代码以文本形式存入一个文档 、
2.进程: 操作系统的一个程序,操作系统管理所有的进程，为它们合理的分配资源.
进程可以通过fork()的方式创建新的进程来执行其它任务，新进程也有自己独立的
内存空间. 因此必须通过进程间通信机制来实现数据共享,因此必须通过进程
间通信机制来实现数据共享,包括: 
1> 管道 
2> 信号
3> 套接字
4> 共享内存区

3.线程: 一个进程可以拥有多个获得cpu调度的执行单元，这个执行单元就是线程。 
由于线程在同一进程下它们可以共享相同的上下文,因此相对于进程而言,线程间
的信息共享和通信更加容易. 

4.python实现并发编程三种方式: 
1>多线程
2>多进程
3>多进程+多线程


5.多进程与多线程的区别: 
1>同一进程中的线程共享同一内存,而进程是独立的
2>同一进程中的所有线程饿数据是共享的,进程之间是独立的
3>对主线程的修改可能会影响其它线程的行为,但父
进程除删除之外不会影响到其它子进程
4>进程包含线程  


6.在python中,无论有多个核,同时只能执行一个线程,这是由于GIL的存在,
当某个线程想要执行,必须先拿到gil,每个进程只有GIL. 
python在使用多线程时,调用的C语言的原生线程 
1>拿到公共数据.  
2>申请GIL.
3>python解释器调用线程执行cpu运算. 
4>当线程执行时间到后,无论运算是否已经执行完,gil都会要求释放. 
5>进而由其它线程重复上述.
6>等其它进程执行完后，又会切换到之前的线程.整个过程是每个线程执行
自己的运算,当执行时间到后就进行切换 


7
python多线程不适用cpu密集型计算任务，这种情况下由于计算工作比较多, 
由于计算工作多，会触发gil的释放与再竞争 

python多线程适用于io密集型任务,文件处理，网络爬虫等涉及文件读写,多线程能够
提升效率.因为单线程下io操作会有io等待,造成不必要的浪费时间. 而多线程在线程a
等待时切换到线程b.


8.守护线程 -daemon 

如果在程序中将自线程设置成守护线程,则该线程会在主线程结束的时候自动退出
一般认为,守护线程不允许离开主线程独立运行
守护线程案例能否有效果跟环境相关

案例01 非守护线程
案例02 守护线程



9.线程常用属性: 
threading.currentThread: 返回当前线程变量
threading.enumerate: 返回一个包含正在运行的线程的list
threading.activeCount: 返回正在运行的线程数量
threading.setName: 给线程设置名字
threading.getName: 得到线程的名字 


10.直接继承子类 threading.Thread
-直接继续Thread,重写run() 
-类实例可以直接运营


11.共享变量 
-当多个线程同时访问一下变量的时候,会产生共享变量的冲突
-解决变量: 锁,信号灯.
-锁(Lock): 是一个标志,表示一个线程在占用一些资源
-使用方法: 
1.上锁
2.使用共享资源,放心的用
3.取消锁,释放锁
-锁谁: 哪个资源需要多个线程共享, 锁哪个
-理解锁: 锁其实不是锁住谁,而是一个标志
-线程安全问题: 
1如果一个资源/var,他对于多线程来讲，不用加锁亦不会引起任何问题,则称为线程安全
2线程不安全变量类型: list,set,dict
3线程安全变量类型: queue(队列,一个变量队形) 


12生产者消费者问题: 
一个模型,可以用来搭建信息队列 
queue是一个用来存放变量的数据结构,特点是线程安全.  内部元素排队,可以理解成特殊的list


13死锁问题 -- dead_lock.py

14semphore : 允许一个资源同时被几个线程同时使用 
- semphore_use_way.py 

15timer : 
- timer是利用多线程,在指定事件后启动一个功能

16可重入锁 
- 一个锁,可以被一个线程多次申请
- 主要解决递归调用的时候,需要申请锁的情况
- threading_mute.py



17.线程替代方案: 
1> subprocess 子进程 
--完全跳过线程,使用进程 
--是派生进程的主要替代方案

2> multiprocessing ---多进程
--使用threading接口派生,使用子进程 
--允许为多核或者多cpu派生进程,接口跟threading非常相似 

-进程间通信(Inter process Communication,IPC)
-进程之间无任何共享状态 
-进程的创建:
    -直接生成process实例对象  : create_process.py
    -派生子类 : opp_process.py
-在os中查看pid,ppid以及它们之间的关系:id_process.py

-生产者消费者模型:
    -JoinableQueue: queue_process.py 
    -好处是起到一个通知的作用


3> concurrent.futures
--新的异步执行模块 
--任务级别的操作